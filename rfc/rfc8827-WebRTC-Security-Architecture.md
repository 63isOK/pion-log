# webrtc里的安全架构

发布日期 2021/01  
发布人 Mozilla

rfc8826介绍了webrtc中有关安全的概念和描述,rfc8827就是具体的安全细节.

## 介绍

rfc8825(WebRTC)是由webrtc工作小组负责标准化的,这个小组叫RTCWEB.
WebRTC的主要应用场景是音视频呼叫/web会议/直接传输数据.
传统的实时系统(eg:基于sip的电话软交换系统rfc3261)和WebRTC系统有所不同,
WebRTC系统中的交互,直接由web server控制,进一步讲,是通过js脚本控制.

一个简单的web server是这样的:

    /******
    * 		+----------------+
    * 		|                |
    * 		|   Web Server   |
    * 		|                |
    * 		+----------------+
    *   		   ^        ^
    * 		    /          \
    * HTTP   /            \   HTTP
    * 		  /              \
    * 	 	 /                \
    *   	v                  v
    * 	JS API              JS API
    * +-----------+            +-----------+
    * |           |    Media   |           |
    * |  Browser  |<---------->|  Browser  |
    * |           |            |           |
    * +-----------+            +-----------+
    ****************************************/

当然服务端也可以设计为多域或域内多服务器模式,服务器之间的通信可以采用基于sdp的sip,
也可以采用xmpp(rfc6120),不管哪种方式,rfc8827的安全架构都是可以满足的.

## trust model

信任模型.

浏览器作为用户的可行人计算库tcb,这种模型假设网络资源存在于浏览器中,任何带安全属性的操作,
都必须由浏览器来保证或通过浏览器验证,这样只要浏览器没有被攻破,就是安全的.

对于浏览器以外的其他实体,都应该认为是不可信的.对于一个功能完备的系统,仅有浏览器还是不够的,
所以浏览器以外的实体(网元)分为了两类:通过浏览器认证的,可以被授权访问敏感资源权限;
另一类是无法认证的,也就是不受信任的.

### 认证网元

系统中主要有两类认证网元:

- 呼叫服务,可以验证来源的网站
- 其他用户,可以加密验证来源的webrtc peer端点(最好是通过dtls-srtp验证)

身份验证通过,并不意味这些实体受到了信任.站点验证通过了,并不意味站点可以访问我们的设备,
这里需要分场合.

### 非认证网元

非认证网元只是意味不可信任,不意味着不进行交互,只是在设计时需要假设非认证网元会作出恶意行为,
即使真是如此,系统也必须是安全的.

## 概述

接下来介绍一个webrtc会话,其中展示各种安全元素和保证,这里面提供更高的用户身份验证和媒体隐私,
同时对调用服务的信任级别也是最低的(这是一个比较严格权衡),实际上在安全/性能/隐私之间还有权衡,
不管权衡如何,都和本文介绍的架构是兼容的.

先描述一下身份和信令,现在大部分都用第三方登录或第三方认证,身份也就是由这些id提供商提供的,
信令更多是指webrtc中,完成会话的必须信令消息.

    /*****
    *                 +----------------+
    *                 |                |
    *                 |     Signaling  |
    *                 |     Server     |
    *                 |                |
    *                 +----------------+
    *                     ^        ^
    *                    /          \
    *            HTTPS  /            \   HTTPS
    *                  /              \
    *                 /                \
    *                v                  v
    *             JS API              JS API
    *       +-----------+            +-----------+
    *       |           |    Media   |           |
    * Alice |  Browser  |<---------->|  Browser  | Bob
    *       |           | (DTLS+SRTP)|           |
    *       +-----------+            +-----------+
    *             ^      ^--+     +--^     ^
    *             |         |     |        |
    *             v         |     |        v
    *       +-----------+   |     |  +-----------+
    *       |           |<--------+  |           |
    *       |   IdP1    |   |        |    IdP2   |
    *       |           |   +------->|           |
    *       +-----------+            +-----------+
    **********************************/

一般信令和身份都是分开的,上图就是一个简单的例子,也有一些跨信令服务的会话:

    /*
    *       +----------------+    Unspecified    +----------------+
    *       |                |      protocol     |                |
    *       |    Signaling   |<----------------->|    Signaling   |
    *       |    Server      |  (SIP, XMPP, ...) |    Server      |
    *       |                |                   |                |
    *       +----------------+                   +----------------+
    *                ^                                   ^
    *                |                                   |
    *          HTTPS |                                   | HTTPS
    *                |                                   |
    *                |                                   |
    *                v                                   v
    *             JS API                               JS API
    *       +-----------+                             +-----------+
    *       |           |             Media           |           |
    * Alice |  Browser  |<--------------------------->|  Browser  | Bob
    *       |           |           DTLS+SRTP         |           |
    *       +-----------+                             +-----------+
    *             ^      ^--+                      +--^     ^
    *             |         |                      |        |
    *             v         |                      |        v
    *       +-----------+   |                      |  +-----------+
    *       |           |<-------------------------+  |           |
    *       |   IdP1    |   |                         |    IdP2   |
    *       |           |   +------------------------>|           |
    *       +-----------+                             +-----------+
    */

上图的一个好处是可将多个web server(一般提供html/js,也提供信令服务)联合起来,
最典型的应用是将多个sfu聚合起来,代价是不同的信令服务之间的交互.

接下来从4个方面来讨论安全,也就是对rfc8826内容的细讲:

- 信令初始化,也是webrtc会话如何开始
- 媒体同意机制的验证,也就是之前提到的ice(握手)
- 流来目标验证之后,用dtls保证数据通道的安全
- 最后还有"同意新鲜度"的问题

### 信令初始化

a呼叫b(eg:a在自己的页面上看到b在线,并点击了呼叫按钮),此时a的页面中,会通过js创建一个
PeerConnection对象,对象直到创建,都不会触发安全检查,之后对象会设置一些媒体属性,
eg:音视频就会创建一个MediaStream,这个stream中会有两个MediaStreamTracks,
一个连到音频输入,一个连到视频输入,此时会做第一次安全检查(浏览器提示a做授权).
一旦stream被添加了,a的浏览器和js会生成一个信令消息,信令消息在rfc8829中描述.

这个信令消息主要包含以下3部分:

- 媒体通道信息
- ice候选(rfc8845描述)
- 一个指纹fingerprint(rfc5763描述),这个指纹用于绑定到密钥

在发送信令消息之前,PeerConnection会联系身份服务获取身份,并将身份和指纹做绑定,
稍后会重点描述指纹绑定这块.

信令消息可以通过websocket(rfc6455)或tls(rfc8446)来发送.
信令服务收到a的消息后,确定是对b的呼叫,并想b的浏览器发送消息.
b浏览器上的js会处理这个消息,并提醒b:有a的来电.
b的浏览器会来联系a的身份提供商,来验证a的身份.
确认之后,可以在b的界面上显示a的名字头像等.

b这边,等浏览器核实之后就会等b用户来同意接收来电,如果b同意了,则会使用a发过来的消息实例化
一个PeerConnection对象,之后b的浏览器触发安全检查,套路和a是一样的:
创建媒体流,触发设备授权,通过信令服务将媒体信息/ice候选信息/指纹发送给a,
如果b和a一样有身份提供服务,也需要带上身份校验信息.

此时,a和b都知道对方想和自己进行安全通话,这个是纯信令实现的,里面的指纹和身份验证可以保证安全.
如果信令服务是跨域联合的,a也可以利用中介来验证b的身份.

身份验证服务是可选的,如果不选,呼叫过程中只知道呼叫者/被呼叫者的信息,类似于匿名呼叫.
坏处是安全保证等级较低,好处是匿名有助于保护隐私.

### 媒体同意的验证

rfc8826上也说了,媒体同意验证是通过ice完成的,a和b都需要执行ice检查,等所有的检查做完了,
就可以发送非ice数据了.

此时,a和b知道对方愿意和自己交换流量,也知道对方的ip地址(ice检查时知道).此时可能有攻击者,
在a和b的传输路径之间(就是中间人攻击),这种情况唯一存在的情况是攻击者也连上了信令服务,
这样攻击者才有ice凭证,如果攻击者连上信令服务,就是合法用户了,所以a和b是有同等的安全保证的.

### dtls握手

一旦ice检查完成,a和b就可以建立一个或多个安全通道,安全通道的建立可以有以下方式:

- dtls, rfc6347
- dtls-srtp, rfc5763
- srtp, rfc3711
- dtls上传sctp, rfc8261

a和b对ice建立的每个ice组件都会建立dtls握手,通道的总数取决于复用数,bundle和rtcp mux,
最好的情况下只用一个通道就ok了,一个通道就意味只有一个dtls握手,握手之后密钥会被导出,
rfc5705,并将密钥用于媒体通道加密srtp.

此时,a和b使用共享密钥来保证安全,而且还没有第三方攻击者知道,如果有身份认证,那a和b就能确保
信令服务不会对她们的流量发起中间人攻击.如果没有身份认证,只要对信令服务有最低限度的信任,
那么她们之间的通信对信令服务也是安全的.

### 交互和同意新鲜度

ice保证了流量目标正确且流量目标同意交换流量,dtls保证了通道中数据的安全,最后剩下的是
"同意新鲜度".

如果b突然离线了,需要有个机制让a验证b是否仍然准备接收流量,有了这个机制,a才不会向已离线的b
发送大量流量.

ice的stun keepalives仅适用于媒体不流动的适合,所以webrtc中需要有个同意新鲜度机制来
定期发送keepalive,这个在rfc7675中描述了.如果keepalive失败,且新的ice通道无法建立,
则意味这会话终止.

前面3点(信令初始化/ice/dtls)是正常流程的处理,最后一点(同意新鲜度)则是保证异常流程.

## sdp的identity属性

在sdp中,identity属性是一个会话级属性,用做远端peer做身份断言,身份断言的值是base64加密串,
在rfc4648的第4节有描述.

本节只讨论了基于peer身份断言和指纹绑定的情况,其他的实现情况不在讨论范围内.

sdp offer/answer中的identity只有一个,多个是未定义的,具体实现中,应该只包含一个,
如果遇到多个,除了第一个,其他应该忽略.

- Name: identity
- Value: identity-assertion
- Usage Level: session
- Charset Dependent: no
- Default Value: N/A

语法如下:

    identity-assertion       = identity-assertion-value
                              *(SP identity-extension)
    identity-assertion-value = base64
    identity-extension       = extension-name [ "=" extension-value ]
    extension-name           = token
    extension-value          = 1*(%x01-09 / %x0b-0c / %x0e-3a / %x3c-ff)
                              ; byte-string from [RFC4566]

    <ALPHA and DIGIT as defined in [RFC4566]>
    <base64 as defined in [RFC4566]>

下面是一个例子:

    a=identity:\
      eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\
      In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\
      IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\
      aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9

虽然identity的值是可以扩展的,但本rfc没有做扩展,应该是其他rfc定义了扩展.

rfc8259规定,身份断言的值(identity-assertion)应该是json编码的字符串(后进行base6编码),
json对象里包含两个字段:assertion和idp,assertion字段对应的值是字符串,
由idp(身份提供服务)来消费,idp字段对应的值是一个数组,包含1-2个idp标识.

上面介绍了sdp中的身份字段,下面介绍一下如何使用:

"初始offer"是指sdp会话中,第一个包含identity字段的offer.(注意:这里仅仅是本rfc的定义),
spd的offer/answer模型在rfc3264中有详细描述.

下面分4块介绍sdp会话:

`生成初始offer`

在生成初始offer时,需要让远端peer来验证我们的身份,就需要在sdp offer中包含一个identity
字段,另外会包含一个或多个fingerprint属性(也就是指纹),indetity需要绑定到所有的指纹属性中.

`生成sdp answer`

answer中的identity和offer中的类似,也需要有绑定动作.区别在于:
answer中的identity可独立包含,也可忽略,而不管offer中是否包含identity.

`处理offer或answer`

当peer收到offer,或answerer产生answer,只要包含identity,
answerer就会联系idp去校验远端peer的身份,
如果需要去第三方idp验证,就需要特定的配置.
如果验证失败,answerer就需要丢弃收到的offer或生成的answer.

`修改sdp会话`

当一个sdp会话修改时,如果指纹未变,那么发送方可以使用同样的identity.
这种情况下,identity必须应用于现有dtls连接,并用其中的指纹建立新连接.
rfc8829第5节规定了:每个媒体块要使用相同的指纹.也就是说:
如果接收者收到一个新的identity,那么这个身份就要应用于所有现有连接.

当然,如果指纹改变了,identity身份必须是新的,要么就不发送身份信息.
因为指纹变化会导致dtls建立新连接,接收者必须丢细先前建立的身份.

## 具体技术

如果是有身份,这样通过身份和指纹可以保证一个较高的安全等级.下面就具体聊聊落地的细节.

下面依次对rfc8826提到过的几个问题作出解答.

### 源和web安全问题

这里的源是同源/跨域的源,rfc6454有描述.

webrtc权限的最小颗粒度就是源,源的安全取决于对源内容进行身份验证,所以https(rfc2818)
才能安全建立源.http源和https源可被视为不同的权限域.

当前浏览器都是默认禁止https页面上的混合内容(一个页面有http和https的内容),
混合内容也不允许访问webrtc的功能.

通话期间,https的页面也可能加载http的内容,这样会导入不安全的js,所以实现中,必须终止调用,
或是提示警告.

无法在源之间移动密钥是安全架构的基石.身份断言倒是可以传递给关心页面的人.

### 设备权限模型

在具体实现中,在访问麦克风/摄像头之前,必须要有用户的明确授权.实现需要满足下面两种权限模型:

- 每次访问设备都需要申请
- 申请一次,永久访问

这两种都是面向https源的.因为http源易受到攻击,所以实现应该拒绝所有http源的权限申请.

此外请求权限应该承诺将授权的媒体发送到单个peer.浏览器应该尽可能向用户表明请求方的身份.

api要求:

要有一套机制,保证发起请求的js无法查看或修改媒体(eg:MediaStream.record).
再结合远端的安全验证,就能保证站点无法访问或修改peer之间的通信.

ui要求:

使用摄像头/麦克风时需要明确指示,不能被js屏蔽;要有明确的终止设备访问指示,
并有ui方式来停止摄像头/麦克风的输入,是那种js也不能阻止的.
这点要求是防止js恶意违规使用设备.

ui要求:

如果意图通过浏览器最小化来掩藏指示,或js创建重叠窗口来覆盖,此时浏览器应该直接停止设备输入.
这点也是为了避免恶意使用设备.

- 浏览器不得允许安装永久屏幕/应用共享,作为对js的响应,相反,应该在用户作出某些操作时才授权
- 请求麦克风/摄像头要单独对话框,请求屏幕/应用共享也需要单独对话框
- 共享应用时,必须有明确的指示,且不能共享不可见的窗口

浏览器可以直接建立数据通道(datachannel),而不需要用户的直接批准.

实现需要支持直接用户认证(下面会描述),前提是有个策略:用户可以直接呼叫已认证过的peer端:

- 允许以后呼叫已经验证过的用户
- 允许以后呼叫地址簿中已验证过的用户

### 交互的同意

实现webrtc的浏览器也实现了ice,服务网关即使运行在公网ip上,也需要实现ice或ice-lite,
这个在rfc8445中有详细描述.

在发送非ice数据之前,需要用ice候选对来验证可达性.也就是说在整个握手期间,不能向js提供ice的
事务id,不能让js访问本地的ufrag/password,就算js知道这些信息,
浏览器也不能通过接口提供这些信息.

之前也提到了ice(rfc8445)的keepalive使用stun绑定身份标识是不能实现"持续同意",
因为她是单向的.所以同意新鲜度需要靠ice来绑定,具体见rfc7675的ice计时器.

### ip位置隐私

ice会泄漏ip,意味位置隐私会泄漏.
一般站点提供http服务,就会获悉用户的服务器侧的地址,下文会重点放在站点上,尽量向远端peer,
隐藏ip地址.

api要求:

api需要提供一种机制,能让js来抑制ice协商,当用户决定接收呼叫后(返回answer之后),
再进行ice协商.这样的好处是:当用户选择不接受呼叫时,远端是无法获取ip信息和是否在线信息.

api要求:

api需要提供一种机制,让js来指定:只使用turn候选.这样做法需要先抑制本地候选和公网ip候选.
好处是:ip地址完全隐藏.

api要求:

api需要提供一种补充机制,让js来重新配置,以添加非turn候选.这个是对上一点的补充.

第一个要求能让用户在接听之前避免ip泄漏,第二个要求能让用户在整个同化过程中避免ip泄漏,
第三个要求是在用户决定不需要隐藏ip时,可以重新配置以允许非turn候选参与匹配,
这样的好处是优化性能.

webrtc没有明确提供机制来支持"代理/特定的nat拓扑",所以说如果要防止ip泄漏,
要么使用仅turn候选,要么代理http/https来修改sdp和js代码.

具体的如何隐藏ip,在rfc8828中描述.

### 通信安全

安全需要支持4块:

- srtp, rfc3711
- dtls, rfc6347
- dtls-srtp, rfc5763, rfc5764
- dtls传sctp, rfc8261

媒体通道(区别于数据通道dataChannel),都是通过srtp/srtcp来保证通道安全,
禁止使用rtp/rtcp发送.具体实现也不能使用null加密,对于每个媒体通道都需要提供dtls-srtp.
webrtc的实现不得选择或提供sdp的安全描述(rfc4568).不得使用srtp的主密钥mki.

所有的数据(媒体通道/数据通道)都需要通过dtls加密.

dtls1.2的TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256和p-256需要支持.
dtls1.0的TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA需要支持.
srtp需要支持dtls-srtp的"保护配置"SRTP_AES128_CM_HMAC_SHA1_80.
dtls1.3正在标准化中.

实现中不能实现dtls重新协商,并用"no_renegotiation"来警告.

rfc7918定义了tls false start,就是tls错误启动,可以将握手延时减少到1rt,
错误启动是tls的可选项,webrtc的endpoint是不能实现false start的.

api要求:

每一次api调用都需要生成一个新的密钥对,用于认证.这是为了实现不可链接性.

api要求:

api需要提供一种方法来重用密钥对,这是用在启用了密钥连续性身份验证的场景,
同时可以分摊密钥生成成本.

api要求:

除非用户配置了外部密钥对,否则每个源都用不同的密钥对.

api要求:

如果dtls-srtp被使用了,那么js就不能获取密钥材料,这样才能保证端到端安全.

ui要求:

面向用户的客户端必须提供检查界面,允许用户确定媒体的"安全特性".

- 需要在浏览器上向用户展示的
  - 客户端需要提供界面,通过界面可以显示当前音视频的安全特性
  - 客户端需要提供一个界面,通过这个界面可以确定麦克风/摄像头的安全特性
  - 如果通过第三方可验视的x.509或idp机制直接验证端点,则安全特性必须包含已验视的信息
- 更加深入的一些信息
  - 安全特性必须指明使用的加密算法
  - 安全特性必须表明是否提供fs(前向安全)
  - 安全特性必须要带外验证机制,eg:指纹/短身份验证字符串sas

## 基于web的认证
